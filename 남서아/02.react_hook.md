# React Hook

Hook은 함수 컴포넌트에서 React state와 생명주기 기능(Lifecycle features)을 “연동(hook into)“할 수 있게 해주는 함수

Hook은 class 안에서는 동작하지 않음 -> 대신 class 없이 React를 사용할 수 있게 해주는 있다.

React는 useState 같은 내장 Hook을 몇 가지 제공

<br><br>

### Lifecycle (생명주기) ???

- mount : 컴포넌트가 페이지에 보여지는 순간

- update : state 등 변경 시 업데이트 되는 순간

- unmount : 컴포넌트가 페이지에서 제거되는 순간

컴포넌트의 생명주기를 알고 있어야 원하는 특정 시기에 코드를 실행할 수 있음 !!

```javascript
Ex]
useEffect(() => {
    // 컴포넌트가 mount, update 시 실행
})
```

<br><br>

# State Hook

## state : 컴포넌트의 상태

예를 들어, 시계라는 컴포넌트가 있다면 state로는 현재 시간을 가질 수 있음

useState는 이 상태를 생성, 갱신하게 해주는 도구

<br>

**useState : 상태 유지 값과 그 값을 갱신하는 함수를 배열 형태로 반환**

```javascript
const [state, setState] = useState(initialState);
const [time, setTime] = useState(12);
```

setState(state 변경함수) : state를 갱신할 때 사용 / 비동기 함수

initialState : 초기 렌더링 시 사용하는 state

최초로 렌더링 하는 동안에는 state 값이 첫 번째 전달된 인자(initialState)의 값과 같음

<br>

- state는 컴포넌트가 다시 렌더링 되어도 그대로 유지됨
- state의 초기값은 첫 번째 전달된 인자(initialState)의 값과 같음 /
  이 초기값은 첫 번째 렌더링에만 딱 한번 사용
- 하나의 컴포넌트 내에서 State Hook을 여러 개 사용 가능

```javascript
function App() {
    const [count, setCount] = useState(0);

    const handleClick = () => {
        setCount(count + 1); // setState를 사용하여 state를 변경하면 해당 컴포넌트는 재렌더링이 된다.
    }

    return (
        <>
        <span>Count : {count}</span>
        <button onClick={handleClick}> Update <button>
        </>
    )

}
```

**setState callback function**

setNames([input, ...prevState]) 이렇게 해도 되지만

여러개의 setState호출문이 같은 state를 동시에 업데이트를 시도할 경우는 콜백을 넣어주는것이 좋다

초기값을 가져올 때 무거운 작업을 해야한다면 콜백함수를 사용하면 됨.

useState 초기값에 콜백형태로 넣어주면 최초 렌더링 시 한번만 함수를 가져옴

<br><br>

# Effect Hook

## useEffect

- 함수의 핵심기능과 상관없는 부가기능을 side Effect 라고 해서 useEffect 라고 함

- 컴포넌트가 렌더링 될 때마다 매번 실행 (state 변경 시 컴포넌트 재랜더링)

- HTML 렌더링 후에 실행!

<br>

```javascript
// 첫번째 인자 : 콜백함수 / 두번째 인자 : 배열

useEffect(() => {}, []);
```

<br>

### 언제 사용??

```javascript
// 어려운 연산 / 서버에서 데이터 가져오는 작업 / 타이머 등..
// 화면을 먼저 보여주고 동작하니 사용자 입장에서는 빠르게 화면을 볼 수 있음

useEffect(() => {
  for (var i = 0; i < 100000; i++) {
    console.log(1);
  }
});
```

<br>

### Ex]

```javascript
// 1)
useEffect(() => {
  console.log("렌더링 될 때마다 매번 실행");
});

// 2)
let [count, setCount] = useEffect(0);

useEffect(() => {
  console.log("렌더링 될 때(mount), count state가 업데이트 될 때");
}, [count]);

// 3)
useEffect(() => {
  console.log("mount 1회만 실행");
}, []);

// 4)
useEffect(() => {
  return () => {
    console.log("코드 실행 전에 항상 실행됨");
  };
});

// 5)
useEffect(() => {
  return () => {
    console.log("컴포넌트 unmount시 1회 실행");
  };
}, []);

// clean up function
useEffect(() => {
  // 2. 그 다음 실행
  let a = setTimeout(() => {
    setAlert(false);
  }, 2000);
  return () => {
    // 1. 먼저 실행
    // 기존 코드 제거 할 때 사용
    clearTimeout(a);
  };
}, []);
```
